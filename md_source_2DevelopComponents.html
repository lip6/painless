<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.12.0" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Painless: Core Interfaces</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <link rel="icon" type="image/png" href="p-logo.png"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/javascript" src="darkmode_toggle.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
  </script>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectlogo"><a href=index.html><img alt="Logo" src="p-logo.png" /></a></td>
              <td id="projectalign">
                <div id="projectname">Painless
                </div>
                <div id="projectbrief">A framework to ease parallelization of sequential CDCL SAT solvers</div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Core Interfaces</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul>
  <li class="level1">
    <a href="#introduction">Introduction</a>
  </li>
  <li class="level1">
    <a href="#autotoc_md1-implementing-solverinterface">1. Implementing SolverInterface</a>
    <ul>
      <li class="level2">
        <a href="#required-functions">Required Functions</a>
      </li>
      <li class="level2">
        <a href="#cdcl-solver-interface">CDCL Solver Interface</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md2-implementing-sharingentity">2. Implementing SharingEntity</a>
    <ul>
      <li class="level2">
        <a href="#required-functions-1">Required Functions</a>
      </li>
      <li class="level2">
        <a href="#default-behaviors">Default Behaviors</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md3-implementing-sharingstrategy">3. Implementing SharingStrategy</a>
    <ul>
      <li class="level2">
        <a href="#required-functions-2">Required Functions</a>
      </li>
      <li class="level2">
        <a href="#default-behaviors-1">Default Behaviors</a>
      </li>
      <li class="level2">
        <a href="#implementation-notes">Implementation Notes</a>
      </li>
      <li class="level2">
        <a href="#globalsharingstrategy-interface">GlobalSharingStrategy Interface</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md4-implementing-clausedatabase">4. Implementing ClauseDatabase</a>
    <ul>
      <li class="level2">
        <a href="#required-functions-3">Required Functions</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#autotoc_md5-implementing-workingstrategy">5. Implementing WorkingStrategy</a>
    <ul>
      <li class="level2">
        <a href="#required-functions-4">Required Functions</a>
      </li>
      <li class="level2">
        <a href="#default-behaviors-2">Default Behaviors</a>
      </li>
      <li class="level2">
        <a href="#implementation-notes-1">Implementation Notes</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#launching-working-strategies">Launching Working Strategies</a>
  </li>
  <li class="level1">
    <a href="#implementation-guidelines">Implementation Guidelines</a>
  </li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="core-interfaces"></a></p>
<h1><a class="anchor" id="introduction"></a>
Introduction</h1>
<p>Painless is built around five main interfaces that you can extend to create new components:</p>
<ul>
<li><a class="el" href="classSolverInterface.html">SolverInterface</a> - Base interface for SAT solvers</li>
<li><a class="el" href="classSharingEntity.html">SharingEntity</a> - Base interface for entities that can exchange clauses</li>
<li><a class="el" href="classSharingStrategy.html">SharingStrategy</a> - Interface for clause sharing strategies</li>
<li><a class="el" href="classClauseDatabase.html">ClauseDatabase</a> - Interface for clause storage</li>
<li><a class="el" href="classWorkingStrategy.html">WorkingStrategy</a> - Interface for solver execution strategies</li>
</ul>
<h1><a class="anchor" id="autotoc_md1-implementing-solverinterface"></a>
1. Implementing SolverInterface</h1>
<p><a class="el" href="classSolverInterface.html">SolverInterface</a> is the base class for implementing SAT solvers. With specialized interfaces <a class="el" href="classSolverCdclInterface.html">SolverCdclInterface</a> and <a class="el" href="classLocalSearchInterface.html">LocalSearchInterface</a>.</p>
<h2><a class="anchor" id="required-functions"></a>
Required Functions</h2>
<p>You must override these pure virtual functions:</p>
<div class="fragment"><div class="line"><span class="comment">// Get the current number of variables</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> getVariablesCount() = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get variable for search splitting</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">int</span> getDivisionVariable() = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set/unset solver interruption</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> setSolverInterrupt() = 0;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> unsetSolverInterrupt() = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Core solving function</span></div>
<div class="line"><span class="keyword">virtual</span> <a class="code hl_enumeration" href="group__solving.html#ga880ec7b4f2828d17a11ecd3548b48ba0">SatResult</a> solve(<span class="keyword">const</span> std::vector&lt;int&gt;&amp; cube) = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Clause management</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> addClause(ClauseExchangePtr clause) = 0;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> addClauses(<span class="keyword">const</span> std::vector&lt;ClauseExchangePtr&gt;&amp; clauses) = 0;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> addInitialClauses(<span class="keyword">const</span> std::vector&lt;simpleClause&gt;&amp; clauses, </div>
<div class="line">                             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nbVars) = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Load formula from DIMACS file</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> loadFormula(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename) = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get model for SAT results</span></div>
<div class="line"><span class="keyword">virtual</span> std::vector&lt;int&gt; getModel() = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Diversification function</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> diversify(<span class="keyword">const</span> SeedGenerator&amp; getSeed) = 0;</div>
<div class="ttc" id="agroup__solving_html_ga880ec7b4f2828d17a11ecd3548b48ba0"><div class="ttname"><a href="group__solving.html#ga880ec7b4f2828d17a11ecd3548b48ba0">SatResult</a></div><div class="ttdeci">SatResult</div><div class="ttdoc">Enumeration for SAT solver results.</div><div class="ttdef"><b>Definition</b> SolverInterface.hpp:39</div></div>
</div><!-- fragment --><p>The interface provides default implementations for:</p>
<ul>
<li><code>printWinningLog()</code> - Prints solver type info</li>
<li><code>printStatistics()</code> - Prints warning that stats aren't implemented</li>
<li><code>printParameters()</code> - Prints warning that parameters aren't implemented</li>
</ul>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Use <code>initializeTypeId&lt;Derived&gt;()</code> function in most derived class' constructors to set up type IDs</li>
<li>The solver type is set via the constructor using <code>SolverAlgorithmType</code></li>
</ul>
</dd></dl>
<h2><a class="anchor" id="cdcl-solver-interface"></a>
CDCL Solver Interface</h2>
<p>The <a class="el" href="classSolverCdclInterface.html" title="Interface for CDCL (Conflict-Driven Clause Learning) solvers This class provides a common interface f...">SolverCdclInterface</a> extends <a class="el" href="classSolverInterface.html" title="Interface for a SAT solver with standard features.">SolverInterface</a> for CDCL (Conflict-Driven Clause Learning) solvers with these additional virtual functions:</p>
<div class="fragment"><div class="line"><span class="comment">// Set the initial phase for a variable</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> setPhase(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> var, <span class="keyword">const</span> <span class="keywordtype">bool</span> phase) = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Increase the activity of a variable</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> bumpVariableActivity(<span class="keyword">const</span> <span class="keywordtype">int</span> var, <span class="keyword">const</span> <span class="keywordtype">int</span> times) = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get final analysis in case of UNSAT result</span></div>
<div class="line"><span class="keyword">virtual</span> std::vector&lt;int&gt; getFinalAnalysis() = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get current SAT solver assumptions</span></div>
<div class="line"><span class="keyword">virtual</span> std::vector&lt;int&gt; getSatAssumptions() = 0;</div>
</div><!-- fragment --><ul>
<li>It inherits from both <a class="el" href="classSolverInterface.html" title="Interface for a SAT solver with standard features.">SolverInterface</a> and <a class="el" href="classSharingEntity.html" title="A base class representing entities that can exchange clauses between themselves.">SharingEntity</a> for clause sharing. Thus the <b>virtual methods from <a class="el" href="classSharingEntity.html" title="A base class representing entities that can exchange clauses between themselves.">SharingEntity</a> must also be implemented</b>.</li>
<li>It includes a clause database (<code>m_clausesToImport</code>) shared pointer for importing received clauses</li>
<li><p class="startli">There is an enum SolverCdclType to identify specific CDCL solver implementations:</p>
<div class="fragment"><div class="line"><span class="keyword">enum class</span> <a class="code hl_enumeration" href="group__solving__cdcl.html#ga83aaf653245e203a7c91c704ef81fc82">SolverCdclType</a> {</div>
<div class="line">    GLUCOSE = 0,</div>
<div class="line">    LINGELING = 1,</div>
<div class="line">    CADICAL = 2,</div>
<div class="line">    MINISAT = 3,</div>
<div class="line">    KISSAT = 4,</div>
<div class="line">    MAPLECOMSPS = 5,</div>
<div class="line">    KISSATMAB = 6,</div>
<div class="line">    KISSATINC = 7</div>
<div class="line">};</div>
<div class="ttc" id="agroup__solving__cdcl_html_ga83aaf653245e203a7c91c704ef81fc82"><div class="ttname"><a href="group__solving__cdcl.html#ga83aaf653245e203a7c91c704ef81fc82">SolverCdclType</a></div><div class="ttdeci">SolverCdclType</div><div class="ttdoc">Code for the type of solvers.</div><div class="ttdef"><b>Definition</b> SolverCdclInterface.hpp:18</div></div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="autotoc_md2-implementing-sharingentity"></a>
2. Implementing SharingEntity</h1>
<p><a class="el" href="classSharingEntity.html">SharingEntity</a> is the base class for components that can exchange clauses. It defines a subscription behavior, where clients subscribes to a producer that exports clauses for them to import.</p>
<h2><a class="anchor" id="required-functions-1"></a>
Required Functions</h2>
<div class="fragment"><div class="line"><span class="comment">// Import a single clause</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">bool</span> importClause(<span class="keyword">const</span> ClauseExchangePtr&amp; clause) = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Import multiple clauses</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> importClauses(<span class="keyword">const</span> std::vector&lt;ClauseExchangePtr&gt;&amp; clauses) = 0;</div>
</div><!-- fragment --><h2><a class="anchor" id="default-behaviors"></a>
Default Behaviors</h2>
<p>The class provides default implementations for:</p>
<ul>
<li><code>addClient()</code> - Adds a sharing entity as a client</li>
<li><code>removeClient()</code> - Removes a client</li>
<li><code>clearClients()</code> - Removes all clients</li>
<li><code>exportClauseToClient()</code> - Basic clause export to a single client</li>
<li><code>exportClause()</code> - Exports clause to all clients</li>
<li><code>exportClauses()</code> - Exports multiple clauses to all clients</li>
<li><code>std::enable_shared_from_this</code> is used, thus objects must be managed by <code>std::shared_ptr</code></li>
<li>Client management uses mutex protection</li>
<li>Automatic sharing ID assignment</li>
<li>Default clause export can be modified by overriding <code>exportClauseToClient()</code></li>
</ul>
<h1><a class="anchor" id="autotoc_md3-implementing-sharingstrategy"></a>
3. Implementing SharingStrategy</h1>
<p><a class="el" href="classSharingStrategy.html">SharingStrategy</a> inherits from <a class="el" href="classSharingEntity.html">SharingEntity</a> and manages clause distribution.</p>
<h2><a class="anchor" id="required-functions-2"></a>
Required Functions</h2>
<div class="fragment"><div class="line"><span class="comment">// Execute the sharing process</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">bool</span> doSharing() = 0;</div>
</div><!-- fragment --><h2><a class="anchor" id="default-behaviors-1"></a>
Default Behaviors</h2>
<p>Provides default implementations for:</p>
<ul>
<li><code>getSleepingTime()</code> - Returns configured sharing sleep time via the option <code>shr-sleep</code></li>
<li><code>printStats()</code> - Prints sharing statistics</li>
<li>Producer/consumer management functions</li>
</ul>
<h2><a class="anchor" id="implementation-notes"></a>
Implementation Notes</h2>
<ul>
<li>Overrides <code>exportClauseToClient()</code> to not export a clause to its producer</li>
<li>Uses a clause database (<code>m_clauseDB</code>) for storing shared clauses</li>
<li>Producer list management uses mutex protection</li>
<li>Returns true from <code>doSharing()</code> when sharing should end (see <a class="el" href="classSharer.html" title="A sharer is a thread responsible for executing a list of SharingStrategies.">Sharer</a>)</li>
</ul>
<h2><a class="anchor" id="globalsharingstrategy-interface"></a>
GlobalSharingStrategy Interface</h2>
<p><a class="el" href="classGlobalSharingStrategy.html" title="Base class for global clause sharing strategies across MPI processes.">GlobalSharingStrategy</a> specializes <a class="el" href="classSharingStrategy.html" title="SharingStrategy class, inheriting from SharingEntity.">SharingStrategy</a> to enable distributed clause sharing through MPI (Message Passing Interface) across multiple processes.</p>
<p><a class="el" href="classGlobalSharingStrategy.html" title="Base class for global clause sharing strategies across MPI processes.">GlobalSharingStrategy</a> adds two functions to the <a class="el" href="classSharingStrategy.html" title="SharingStrategy class, inheriting from SharingEntity.">SharingStrategy</a> interface:</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> initMpiVariable() = 0;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> joinProcess() = 0;</div>
</div><!-- fragment --><ul>
<li><code>initMpiVariable()</code> sets up the MPI related variables for distributed communication.</li>
<li><code>joinProcess()</code> provides synchronization mechanisms for process termination and resource cleanup.</li>
</ul>
<p>It also overrides <code>doSharing()</code> to execute a periodic end detection algorithm. It returns true when the sharing process should terminate based on global consensus. Thus <code><a class="el" href="classGlobalSharingStrategy.html#a375a351c2c456d98393eb9d4a72cae6d" title="Performs the clause sharing operation.">GlobalSharingStrategy::doSharing()</a></code> can be used in derived classes for termination detection.</p>
<h1><a class="anchor" id="autotoc_md4-implementing-clausedatabase"></a>
4. Implementing ClauseDatabase</h1>
<p><a class="el" href="classClauseDatabase.html">ClauseDatabase</a> is the base class for clause storage implementations. The <a class="el" href="classClauseBuffer.html">ClauseBuffer</a> class presented in <a class="el" href="md_source_2ClauseManagement.html">Clause Management</a> can be used as a basis for an hypothetical implementation.</p>
<h2><a class="anchor" id="required-functions-3"></a>
Required Functions</h2>
<div class="fragment"><div class="line"><span class="comment">// Add a single clause to the database</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">bool</span> addClause(ClauseExchangePtr clause) = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get clauses up to the literal count limit</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">size_t</span> giveSelection(std::vector&lt;ClauseExchangePtr&gt;&amp; selectedCls,</div>
<div class="line">                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> literalCountLimit) = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get all clauses from the database</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> getClauses(std::vector&lt;ClauseExchangePtr&gt;&amp; v_cls) = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get a single clause from the database</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">bool</span> getOneClause(ClauseExchangePtr&amp; cls) = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get current database size</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">size_t</span> getSize() <span class="keyword">const</span> = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Reduce database size</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">size_t</span> shrinkDatabase() = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Remove all clauses</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> clearDatabase() = 0;</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md5-implementing-workingstrategy"></a>
5. Implementing WorkingStrategy</h1>
<p><a class="el" href="classWorkingStrategy.html">WorkingStrategy</a> defines how solvers are executed. Currently, it is the component where all the other components are to be managed in order to achieve the needed parallelization or distributed strategy.</p>
<h2><a class="anchor" id="required-functions-4"></a>
Required Functions</h2>
<div class="fragment"><div class="line"><span class="comment">// Core solving function</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> solve(<span class="keyword">const</span> std::vector&lt;int&gt;&amp; cube) = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Handle solver completion</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> join(<a class="code hl_class" href="classWorkingStrategy.html">WorkingStrategy</a>* winner, <a class="code hl_enumeration" href="group__solving.html#ga880ec7b4f2828d17a11ecd3548b48ba0">SatResult</a> res, </div>
<div class="line">                 <span class="keyword">const</span> std::vector&lt;int&gt;&amp; model) = 0;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Control solver execution</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> setSolverInterrupt() = 0;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> unsetSolverInterrupt() = 0;</div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> waitInterrupt() = 0;</div>
<div class="ttc" id="aclassWorkingStrategy_html"><div class="ttname"><a href="classWorkingStrategy.html">WorkingStrategy</a></div><div class="ttdoc">Base Interface for Working Strategies.</div><div class="ttdef"><b>Definition</b> WorkingStrategy.hpp:18</div></div>
</div><!-- fragment --><h2><a class="anchor" id="default-behaviors-2"></a>
Default Behaviors</h2>
<p>Provides:</p>
<ul>
<li><code>addSlave()</code> - Adds a child working strategy</li>
</ul>
<h2><a class="anchor" id="implementation-notes-1"></a>
Implementation Notes</h2>
<ul>
<li>Uses parent-child relationships</li>
<li>Implements solver execution patterns</li>
<li>Launched from main() in painless.cpp</li>
<li>Controls solver lifecycle</li>
</ul>
<h1><a class="anchor" id="launching-working-strategies"></a>
Launching Working Strategies</h1>
<p>In <code>painless.cpp</code>, working strategies are initialized and launched:</p>
<div class="fragment"><div class="line"><span class="comment">// Create working strategy</span></div>
<div class="line"><span class="keywordflow">if</span> (__globalParameters__.test)</div>
<div class="line">    working = <span class="keyword">new</span> Test();</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (__globalParameters__.simple)</div>
<div class="line">    working = <span class="keyword">new</span> <a class="code hl_class" href="classPortfolioSimple.html">PortfolioSimple</a>();</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">    working = <span class="keyword">new</span> <a class="code hl_class" href="classPortfolioPRS.html">PortfolioPRS</a>(); <span class="comment">// The current default (will be changed)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Launch working strategy</span></div>
<div class="line">std::vector&lt;int&gt; cube;</div>
<div class="line">std::thread mainWorker(&amp;WorkingStrategy::solve, working, std::ref(cube));</div>
<div class="ttc" id="aclassPortfolioPRS_html"><div class="ttname"><a href="classPortfolioPRS.html">PortfolioPRS</a></div><div class="ttdoc">An Implementation of WorkingStrategy that mimics the strategy used in the PRS-Distributed solver from...</div><div class="ttdef"><b>Definition</b> PortfolioPRS.hpp:35</div></div>
<div class="ttc" id="aclassPortfolioSimple_html"><div class="ttname"><a href="classPortfolioSimple.html">PortfolioSimple</a></div><div class="ttdoc">A Simple Implementation of WorkingStrategy for the portfolio parallel strategy This strategy uses the...</div><div class="ttdef"><b>Definition</b> PortfolioSimple.hpp:24</div></div>
</div><!-- fragment --><h1><a class="anchor" id="implementation-guidelines"></a>
Implementation Guidelines</h1>
<ol type="1">
<li>Reference existing implementations in <code>src/solvers/PortfolioSimple.cpp</code>, <code>src/solvers/AllgatherSharing.cpp</code>, ...</li>
<li>Implement synchronization for thread safety</li>
<li>Follow shared pointer memory management patterns</li>
<li>Include logging for debugging</li>
<li>Test with different SAT instances </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.12.0-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<img class="footer" src="./p-logo.png"/>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
Doxygen Theme by&#160;<a href="https://github.com/jothepro/doxygen-awesome-css">doxygen-awesome</a>
</small></address>
</div><!-- doc-content -->
</body>
</html>
