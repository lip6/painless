<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=11" />
  <meta name="generator" content="Doxygen 1.12.0" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Painless: Clause Management in Painless: ClauseExchange and ClauseBuffer</title>
  <link href="tabs.css" rel="stylesheet" type="text/css" />
  <link rel="icon" type="image/png" href="p-logo.png"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
  <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/javascript" src="darkmode_toggle.js"></script>
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
  <script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
  </script>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr id="projectrow">
              <td id="projectlogo"><a href=index.html><img alt="Logo" src="p-logo.png" /></a></td>
              <td id="projectalign">
                <div id="projectname">Painless
                </div>
                <div id="projectbrief">A framework to ease parallelization of sequential CDCL SAT solvers</div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Clause Management in Painless: ClauseExchange and ClauseBuffer</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul>
  <li class="level1">
    <a href="#clauseexchange">ClauseExchange</a>
    <ul>
      <li class="level2">
        <a href="#key-features">Key Features</a>
      </li>
      <li class="level2">
        <a href="#usage-example">Usage Example</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#clausebuffer">ClauseBuffer</a>
    <ul>
      <li class="level2">
        <a href="#key-features-1">Key Features</a>
      </li>
      <li class="level2">
        <a href="#usage-example-1">Usage Example</a>
      </li>
    </ul>
  </li>
  <li class="level1">
    <a href="#torawptr-and-fromrawptr">toRawPtr and fromRawPtr</a>
  </li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="clause-management-in-painless-clauseexchange-and-clausebuffer"></a></p>
<h1><a class="anchor" id="clauseexchange"></a>
ClauseExchange</h1>
<p><a class="el" href="classClauseExchange.html">ClauseExchange</a> is a memory-efficient class for storing and managing SAT clauses of varying sizes. It uses a <a href="http://wiki.c2.com/?StructHack">flexible array member</a> for optimized memory usage and intrusive reference counting for efficient memory management.</p>
<h2><a class="anchor" id="key-features"></a>
Key Features</h2>
<ol type="1">
<li><b>Memory Layout</b><ul>
<li>Uses a flexible array member (<code>lits[0]</code>) for storing literals</li>
<li>Fixed-size header containing: <div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lbd;          <span class="comment">// Literal Block Distance</span></div>
<div class="line"><span class="keywordtype">int</span> from;                  <span class="comment">// Source identifier</span></div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size;         <span class="comment">// Number of literals</span></div>
<div class="line">std::atomic&lt;unsigned int&gt; refCounter; <span class="comment">// Reference count</span></div>
</div><!-- fragment --></li>
</ul>
</li>
<li><b>Smart Pointer Management</b><ul>
<li>Uses <code>boost::intrusive_ptr</code> for reference counting</li>
<li>Type alias: <code>using ClauseExchangePtr = boost::intrusive_ptr&lt;<a class="el" href="classClauseExchange.html" title="Represents an exchangeable clause with flexible array member.">ClauseExchange</a>&gt;</code></li>
<li>Custom reference counting through: <div class="fragment"><div class="line"><span class="keywordtype">void</span> intrusive_ptr_add_ref(<a class="code hl_class" href="classClauseExchange.html">ClauseExchange</a>* ce);</div>
<div class="line"><span class="keywordtype">void</span> intrusive_ptr_release(<a class="code hl_class" href="classClauseExchange.html">ClauseExchange</a>* ce);</div>
<div class="ttc" id="aclassClauseExchange_html"><div class="ttname"><a href="classClauseExchange.html">ClauseExchange</a></div><div class="ttdoc">Represents an exchangeable clause with flexible array member.</div><div class="ttdef"><b>Definition</b> ClauseExchange.hpp:42</div></div>
</div><!-- fragment --></li>
</ul>
</li>
<li><b>Iterator Support</b><ul>
<li>STL-compatible iterators</li>
<li>Supports range-based for loops <div class="fragment"><div class="line"><span class="comment">// Begin/end iterators</span></div>
<div class="line"><span class="keywordtype">int</span>* begin();</div>
<div class="line"><span class="keywordtype">int</span>* end();</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span>* begin() <span class="keyword">const</span>;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span>* end() <span class="keyword">const</span>;</div>
</div><!-- fragment --></li>
</ul>
</li>
<li><b>Utility Functions</b> <div class="fragment"><div class="line"><span class="comment">// Array-style access</span></div>
<div class="line"><span class="keywordtype">int</span>&amp; operator[](<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index);</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span>&amp; operator[](<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index) <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Sorting functions</span></div>
<div class="line"><span class="keywordtype">void</span> sortLiterals();</div>
<div class="line"><span class="keywordtype">void</span> sortLiteralsDescending();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Debug support</span></div>
<div class="line">std::string toString() <span class="keyword">const</span>;</div>
</div><!-- fragment --></li>
<li><b>LBD Handling</b><ul>
<li>Forces LBD â‰¥ 2 for non-unit clauses</li>
<li>Unit clauses can have LBD of 0 or 1 (I am thinking of forcing it to 0).</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="usage-example"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Create a clause with 3 literals</span></div>
<div class="line"><span class="keyword">auto</span> clause = <a class="code hl_function" href="classClauseExchange.html#ac77a818f0880dc6b1e0caddee43aeba9">ClauseExchange::create</a>(3, 2, 1);  <span class="comment">// size=3, lbd=2, from=1</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fill literals</span></div>
<div class="line">clause-&gt;lits[0] = 1;</div>
<div class="line">clause-&gt;lits[1] = -2;</div>
<div class="line">clause-&gt;lits[2] = 3;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Or using iterators</span></div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span>&amp; lit : *clause) {</div>
<div class="line">    <span class="comment">// Process literals</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassClauseExchange_html_ac77a818f0880dc6b1e0caddee43aeba9"><div class="ttname"><a href="classClauseExchange.html#ac77a818f0880dc6b1e0caddee43aeba9">ClauseExchange::create</a></div><div class="ttdeci">static ClauseExchangePtr create(const unsigned int size, const unsigned int lbd=0, const int from=-1)</div><div class="ttdoc">Create a new ClauseExchange object.</div></div>
</div><!-- fragment --><h1><a class="anchor" id="clausebuffer"></a>
ClauseBuffer</h1>
<p><a class="el" href="classClauseBuffer.html">ClauseBuffer</a> is a thread-safe buffer for exchanging clauses between producers and consumers. It's built on top of <code>boost::lockfree::queue</code> for efficient multiple producers-multiple consumers operations.</p>
<h2><a class="anchor" id="key-features-1"></a>
Key Features</h2>
<ol type="1">
<li><b>Lock-Free Operations</b><ul>
<li>Based on <code>boost::lockfree::queue</code></li>
<li>Non-fixed size queue</li>
<li>Multiple producer/consumer safe</li>
</ul>
</li>
<li><b>Atomic Size Tracking</b> <div class="fragment"><div class="line">std::atomic&lt;size_t&gt; m_size;  <span class="comment">// Current number of elements</span></div>
</div><!-- fragment --></li>
<li><b>Clause Addition</b> <div class="fragment"><div class="line"><span class="comment">// Add single clause</span></div>
<div class="line"><span class="keywordtype">bool</span> addClause(ClauseExchangePtr clause);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add multiple clauses</span></div>
<div class="line"><span class="keywordtype">size_t</span> addClauses(<span class="keyword">const</span> std::vector&lt;ClauseExchangePtr&gt;&amp; clauses);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Bounded versions (with capacity limit)</span></div>
<div class="line"><span class="keywordtype">bool</span> tryAddClauseBounded(ClauseExchangePtr clause);</div>
<div class="line"><span class="keywordtype">size_t</span> tryAddClausesBounded(<span class="keyword">const</span> std::vector&lt;ClauseExchangePtr&gt;&amp; clauses);</div>
</div><!-- fragment --></li>
<li><b>Clause Retrieval</b> <div class="fragment"><div class="line"><span class="comment">// Get single clause</span></div>
<div class="line"><span class="keywordtype">bool</span> getClause(ClauseExchangePtr&amp; clause);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get all available clauses</span></div>
<div class="line"><span class="keywordtype">void</span> getClauses(std::vector&lt;ClauseExchangePtr&gt;&amp; clauses);</div>
</div><!-- fragment --></li>
<li><b>Utility Functions</b> <div class="fragment"><div class="line"><span class="comment">// Get current size</span></div>
<div class="line"><span class="keywordtype">size_t</span> size() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Check if empty</span></div>
<div class="line"><span class="keywordtype">bool</span> empty() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Clear all clauses</span></div>
<div class="line"><span class="keywordtype">void</span> clear();</div>
</div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="usage-example-1"></a>
Usage Example</h2>
<div class="fragment"><div class="line"><span class="comment">// Create buffer with initial capacity</span></div>
<div class="line"><a class="code hl_class" href="classClauseBuffer.html">ClauseBuffer</a> buffer(1000);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Producer code</span></div>
<div class="line"><span class="keyword">auto</span> clause = <a class="code hl_function" href="classClauseExchange.html#ac77a818f0880dc6b1e0caddee43aeba9">ClauseExchange::create</a>(<span class="comment">/* ... */</span>);</div>
<div class="line"><span class="keywordflow">if</span> (buffer.addClause(clause)) {</div>
<div class="line">    <span class="comment">// Successfully added</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Consumer code</span></div>
<div class="line">ClauseExchangePtr received;</div>
<div class="line"><span class="keywordflow">if</span> (buffer.getClause(received)) {</div>
<div class="line">    <span class="comment">// Process received clause</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Batch operations</span></div>
<div class="line">std::vector&lt;ClauseExchangePtr&gt; clauses;</div>
<div class="line">buffer.getClauses(clauses);  <span class="comment">// Get all available clauses</span></div>
<div class="ttc" id="aclassClauseBuffer_html"><div class="ttname"><a href="classClauseBuffer.html">ClauseBuffer</a></div><div class="ttdoc">Wrapper for boost::lockfree::queue to manage ClauseExchange objects.</div><div class="ttdef"><b>Definition</b> ClauseBuffer.hpp:26</div></div>
</div><!-- fragment --><h1><a class="anchor" id="torawptr-and-fromrawptr"></a>
toRawPtr and fromRawPtr</h1>
<p><a class="el" href="classClauseBuffer.html" title="Wrapper for boost::lockfree::queue to manage ClauseExchange objects.">ClauseBuffer</a> internally uses <code>boost::lockfree::queue</code> which operates on raw pointers, while the external interface uses <code>ClauseExchangePtr</code> (smart pointers). The <code>toRawPtr</code> and <code>fromRawPtr</code> methods of <a class="el" href="classClauseExchange.html" title="Represents an exchangeable clause with flexible array member.">ClauseExchange</a> bridge this gap safely.</p>
<div class="fragment"><div class="line"><span class="comment">// In ClauseExchange</span></div>
<div class="line"><a class="code hl_class" href="classClauseExchange.html">ClauseExchange</a>* toRawPtr() {</div>
<div class="line">    refCounter.fetch_add(1, std::memory_order_relaxed);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// It is static, but we interact with the same ClauseExchange instance, since we have its pointer.</span></div>
<div class="line"><span class="keyword">static</span> ClauseExchangePtr fromRawPtr(<a class="code hl_class" href="classClauseExchange.html">ClauseExchange</a>* ptr) {</div>
<div class="line">    <span class="keywordflow">return</span> ClauseExchangePtr(ptr, <span class="keyword">false</span>); <span class="comment">// false is to not increment the reference counter, since it was incremented at toRawPtr().</span></div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><b>Usage in <a class="el" href="classClauseBuffer.html" title="Wrapper for boost::lockfree::queue to manage ClauseExchange objects.">ClauseBuffer</a> :</b></li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="classClauseBuffer.html#a65c019d0b60af8a93e2432bbd96083de">ClauseBuffer::addClause</a>(ClauseExchangePtr clause) {</div>
<div class="line">    <span class="comment">// Convert to raw pointer while incrementing ref count</span></div>
<div class="line">    <a class="code hl_class" href="classClauseExchange.html">ClauseExchange</a>* raw = clause-&gt;<a class="code hl_function" href="classClauseExchange.html#a14a7a8d2fdd6f7125164619e722341cc">toRawPtr</a>();</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (queue.push(raw)) {</div>
<div class="line">        m_size.fetch_add(1, std::memory_order_release);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// Reference count is decremented since the returned ClauseExchangePtr is not stored</span></div>
<div class="line">        <a class="code hl_function" href="classClauseExchange.html#a8bf1d196b50c4c5a42a06d48d7c9ed29">ClauseExchange::fromRawPtr</a>(raw);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> <a class="code hl_function" href="classClauseBuffer.html#ae09a37807866d26de150bf74a669f3cb">ClauseBuffer::getClause</a>(ClauseExchangePtr&amp; clause) {</div>
<div class="line">    <a class="code hl_class" href="classClauseExchange.html">ClauseExchange</a>* raw;</div>
<div class="line">    <span class="keywordflow">if</span> (queue.pop(raw)) {</div>
<div class="line">        <span class="comment">// Convert back to smart pointer without incrementing ref count</span></div>
<div class="line">        clause = <a class="code hl_function" href="classClauseExchange.html#a8bf1d196b50c4c5a42a06d48d7c9ed29">ClauseExchange::fromRawPtr</a>(raw);</div>
<div class="line">        m_size.fetch_sub(1, std::memory_order_release);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="ttc" id="aclassClauseBuffer_html_a65c019d0b60af8a93e2432bbd96083de"><div class="ttname"><a href="classClauseBuffer.html#a65c019d0b60af8a93e2432bbd96083de">ClauseBuffer::addClause</a></div><div class="ttdeci">bool addClause(ClauseExchangePtr clause)</div><div class="ttdoc">Adds a single clause to the buffer.</div><div class="ttdef"><b>Definition</b> ClauseBuffer.hpp:82</div></div>
<div class="ttc" id="aclassClauseBuffer_html_ae09a37807866d26de150bf74a669f3cb"><div class="ttname"><a href="classClauseBuffer.html#ae09a37807866d26de150bf74a669f3cb">ClauseBuffer::getClause</a></div><div class="ttdeci">bool getClause(ClauseExchangePtr &amp;clause)</div><div class="ttdoc">Retrieves a single clause from the buffer.</div><div class="ttdef"><b>Definition</b> ClauseBuffer.hpp:158</div></div>
<div class="ttc" id="aclassClauseExchange_html_a14a7a8d2fdd6f7125164619e722341cc"><div class="ttname"><a href="classClauseExchange.html#a14a7a8d2fdd6f7125164619e722341cc">ClauseExchange::toRawPtr</a></div><div class="ttdeci">ClauseExchange * toRawPtr()</div><div class="ttdoc">Convert to a raw pointer and increment the reference count.</div><div class="ttdef"><b>Definition</b> ClauseExchange.hpp:151</div></div>
<div class="ttc" id="aclassClauseExchange_html_a8bf1d196b50c4c5a42a06d48d7c9ed29"><div class="ttname"><a href="classClauseExchange.html#a8bf1d196b50c4c5a42a06d48d7c9ed29">ClauseExchange::fromRawPtr</a></div><div class="ttdeci">static ClauseExchangePtr fromRawPtr(ClauseExchange *ptr)</div><div class="ttdoc">Create an intrusive_ptr from a raw pointer.</div><div class="ttdef"><b>Definition</b> ClauseExchange.hpp:162</div></div>
</div><!-- fragment --><ul>
<li><code>toRawPtr()</code>: Increments reference count before storing in queue</li>
<li><code>fromRawPtr()</code>: Creates smart pointer without additional increment</li>
</ul>
<dl class="section important"><dt>Important</dt><dd>A ClauseExchangePtr should not be gotten through <code>.get()</code>: <div class="fragment"><div class="line"><span class="comment">// DON&#39;T: Direct raw pointer usage</span></div>
<div class="line"><a class="code hl_class" href="classClauseExchange.html">ClauseExchange</a>* raw = clause.get();  <span class="comment">// Wrong! Bypasses ref counting</span></div>
<div class="line"><span class="comment">// DO: Use provided conversion methods</span></div>
<div class="line"><a class="code hl_class" href="classClauseExchange.html">ClauseExchange</a>* raw = clause-&gt;<a class="code hl_function" href="classClauseExchange.html#a14a7a8d2fdd6f7125164619e722341cc">toRawPtr</a>();</div>
</div><!-- fragment --> Be careful to not leave hanging raw pointers, otherwise the <a class="el" href="classClauseExchange.html" title="Represents an exchangeable clause with flexible array member.">ClauseExchange</a> instance will never be freed.</dd></dl>
<ul>
<li><b>Example Flow :</b></li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Life cycle of a clause through the buffer</span></div>
<div class="line"><a class="code hl_class" href="classClauseBuffer.html">ClauseBuffer</a> queue(10)</div>
<div class="line">{</div>
<div class="line">    ClauseExchangePtr clause = <a class="code hl_function" href="classClauseExchange.html#ac77a818f0880dc6b1e0caddee43aeba9">ClauseExchange::create</a>(3);  <span class="comment">// ref_count = 1</span></div>
<div class="line">    queue.addClause(raw);                                  <span class="comment">// ref_count = 2</span></div>
<div class="line">    <span class="comment">// Original clause goes out of scope                   // ref_count = 1</span></div>
<div class="line">}</div>
<div class="line">ClauseExchangePtr newClause;        </div>
<div class="line">queue.getClause(newClause);                            <span class="comment">// Same ref_count = 1</span></div>
<div class="line"><span class="comment">// newClause handles final cleanup                     // ref_count = 0</span></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.12.0-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
<img class="footer" src="./p-logo.png"/>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
Doxygen Theme by&#160;<a href="https://github.com/jothepro/doxygen-awesome-css">doxygen-awesome</a>
</small></address>
</div><!-- doc-content -->
</body>
</html>
